[[channel]]
=== Message Channels

While the `Message` plays the crucial role of encapsulating data, it is the `MessageChannel` that decouples message producers from message consumers.

[[channel-interfaces]]
==== The MessageChannel Interface

Spring Integration's top-level `MessageChannel` interface is defined as follows.

[source,java]
----
public interface MessageChannel {

    boolean send(Message message);

    boolean send(Message message, long timeout);
}
----

When sending a message, the return value will be _true_ if the message is sent successfully.
If the send call times out or is interrupted, then it will return _false_.

[[channel-interfaces-pollablechannel]]
===== PollableChannel

Since Message Channels may or may not buffer Messages (as discussed in the overview), there are two sub-interfaces defining the buffering (pollable) and non-buffering (subscribable) channel behavior.
Here is the definition of `PollableChannel`.

[source,java]
----
public interface PollableChannel extends MessageChannel {

    Message<?> receive();

    Message<?> receive(long timeout);

}
----

Similar to the send methods, when receiving a message, the return value will be _null_ in the case of a timeout or interrupt.

[[channel-interfaces-subscribablechannel]]
===== SubscribableChannel

The `SubscribableChannel` base interface is implemented by channels that send Messages directly to their subscribed `MessageHandler` s.
Therefore, they do not provide receive methods for polling, but instead define methods for managing those subscribers:
[source,java]
----
public interface SubscribableChannel extends MessageChannel {

    boolean subscribe(MessageHandler handler);

    boolean unsubscribe(MessageHandler handler);

}
----

[[channel-implementations]]
==== Message Channel Implementations

Spring Integration provides several different Message Channel implementations.
Each is briefly described in the sections below.

[[channel-implementations-publishsubscribechannel]]
===== PublishSubscribeChannel

The `PublishSubscribeChannel` implementation broadcasts any Message sent to it to all of its subscribed handlers.
This is most often used for sending_Event Messages_ whose primary role is notification as opposed to _Document Messages_ which are generally intended to be processed by a single handler.
Note that the `PublishSubscribeChannel` is intended for sending only.
Since it broadcasts to its subscribers directly when its` send(Message)` method is invoked, consumers cannot poll for Messages (it does not implement `PollableChannel` and therefore has no `receive()` method).
Instead, any subscriber must be a `MessageHandler` itself, and the subscriber's `handleMessage(Message)` method will be invoked in turn.

Prior to version 3.0, invoking the send method on a `PublishSubscribeChannel` that had no subscribers returned `false`.
When used in conjunction with a `MessagingTemplate`, a `MessageDeliveryException` was thrown.
Starting with version 3.0, the behavior has changed such that a send is always considered successful if at least the minimum subscribers are present (and successfully handle the message).
This behavior can be modified by setting the `minSubscribers` property, which defaults to `0`.

NOTE: If a `TaskExecutor` is used, only the presence of the correct number of subscribers is used for this determination, because the actual handling of the message is performed asynchronously.

[[channel-implementations-queuechannel]]
===== QueueChannel

The `QueueChannel` implementation wraps a queue.
Unlike the `PublishSubscribeChannel`, the `QueueChannel` has point-to-point semantics.
In other words, even if the channel has multiple consumers, only one of them should receive any Message sent to that channel.
It provides a default no-argument constructor (providing an essentially unbounded capacity of `Integer.MAX_VALUE`) as well as a constructor that accepts the queue capacity:
[source,java]
----
public QueueChannel(int capacity)
----

A channel that has not reached its capacity limit will store messages in its internal queue, and the `send()` method will return immediately even if no receiver is ready to handle the message.
If the queue has reached capacity, then the sender will block until room is available.
Or, if using the send call that accepts a timeout, it will block until either room is available or the timeout period elapses, whichever occurs first.
Likewise, a receive call will return immediately if a message is available on the queue, but if the queue is empty, then a receive call may block until either a message is available or the timeout elapses.
In either case, it is possible to force an immediate return regardless of the queue's state by passing a timeout value of 0.
Note however, that calls to the no-arg versions of `send()` and `receive()` will block indefinitely.

[[channel-implementations-prioritychannel]]
===== PriorityChannel

Whereas the `QueueChannel` enforces first-in/first-out (FIFO) ordering, the `PriorityChannel` is an alternative implementation that allows for messages to be ordered within the channel based upon a priority.
By default the priority is determined by the '`priority`' header within each message.
However, for custom priority determination logic, a comparator of type `Comparator<Message<?>>` can be provided to the `PriorityChannel`'s constructor.

[[channel-implementations-rendezvouschannel]]
===== RendezvousChannel

The `RendezvousChannel` enables a "direct-handoff" scenario where a sender will block until another party invokes the channel's `receive()` method or vice-versa.
Internally, this implementation is quite similar to the `QueueChannel` except that it uses a `SynchronousQueue` (a zero-capacity implementation of `BlockingQueue`).
This works well in situations where the sender and receiver are operating in different threads but simply dropping the message in a queue asynchronously is not appropriate.
In other words, with a `RendezvousChannel` at least the sender knows that some receiver has accepted the message, whereas with a `QueueChannel`, the message would have been stored to the internal queue and potentially never received.

TIP: Keep in mind that all of these queue-based channels are storing messages in-memory only by default.
When persistence is required, you can either provide a 'message-store' attribute within the 'queue' element to reference a persistent MessageStore implementation, or you can replace the local channel with one that is backed by a persistent broker, such as a JMS-backed channel or Channel Adapter.
The latter option allows you to take advantage of any JMS provider's implementation for message persistence, and it will be discussed in <<jms>>.
However, when buffering in a queue is not necessary, the simplest approach is to rely upon the `DirectChannel` discussed next.

The `RendezvousChannel` is also useful for implementing request-reply operations.
The sender can create a temporary, anonymous instance of `RendezvousChannel` which it then sets as the 'replyChannel' header when building a Message.
After sending that Message, the sender can immediately call receive (optionally providing a timeout value) in order to block while waiting for a reply Message.
This is very similar to the implementation used internally by many of Spring Integration's request-reply components.

[[channel-implementations-directchannel]]
===== DirectChannel

The `DirectChannel` has point-to-point semantics but otherwise is more similar to the `PublishSubscribeChannel` than any of the queue-based channel implementations described above.
It implements the `SubscribableChannel` interface instead of the `PollableChannel` interface, so it dispatches Messages directly to a subscriber.
As a point-to-point channel, however, it differs from the `PublishSubscribeChannel` in that it will only send each Message to a _single_ subscribed `MessageHandler`.

In addition to being the simplest point-to-point channel option, one of its most important features is that it enables a single thread to perform the operations on "both sides" of the channel.
For example, if a handler is subscribed to a `DirectChannel`, then sending a Message to that channel will trigger invocation of that handler's `handleMessage(Message)` method _directly in the
        sender's thread_, before the send() method invocation can return.

The key motivation for providing a channel implementation with this behavior is to support transactions that must span across the channel while still benefiting from the abstraction and loose coupling that the channel provides.
If the send call is invoked within the scope of a transaction, then the outcome of the handler's invocation (e.g.
updating a database record) will play a role in determining the ultimate result of that transaction (commit or rollback).

NOTE: Since the `DirectChannel` is the simplest option and does not add any additional overhead that would be required for scheduling and managing the threads of a poller, it is the default channel type within Spring Integration.
The general idea is to define the channels for an application and then to consider which of those need to provide buffering or to throttle input, and then modify those to be queue-based `PollableChannels`.
Likewise, if a channel needs to broadcast messages, it should not be a `DirectChannel` but rather a `PublishSubscribeChannel`.
Below you will see how each of these can be configured.

The `DirectChannel` internally delegates to a Message Dispatcher to invoke its subscribed Message Handlers, and that dispatcher can have a load-balancing strategy exposed via_load-balancer_ or _load-balancer-ref_ attributes (mutually exclusive).
The load balancing strategy is used by the Message Dispatcher to help determine how Messages are distributed amongst Message Handlers in the case that there are multiple Message Handlers subscribed to the same channel.
As a convinience the _load-balancer_ attribute exposes enumeration of values pointing to pre-existing implementations of `LoadBalancingStrategy`.
The "round-robin" (load-balances across the handlers in rotation) and "none" (for the cases where one wants to explicitely disable load balancing) are the only available values.
Other strategy implementations may be added in future versions.
However, since version 3.0 you can provide your own implementation of the `LoadBalancingStrategy` and inject it using _load-balancer-ref_ attribute which should point to a bean that implements `LoadBalancingStrategy`.

[source,xml]
----
<int:channel id="lbRefChannel">
  <int:dispatcher load-balancer-ref="lb"/>
</int:channel>

<bean id="lb" class="foo.bar.SampleLoadBalancingStrategy"/>
----

Note that _load-balancer_ or _load-balancer-ref_ attributes are mutually exclusive.

The load-balancing also works in combination with a boolean _failover_ property.
If the "failover" value is true (the default), then the dispatcher will fall back to any subsequent handlers as necessary when preceding handlers throw Exceptions.
The order is determined by an optional order value defined on the handlers themselves or, if no such value exists, the order in which the handlers are subscribed.

If a certain situation requires that the dispatcher always try to invoke the first handler, then fallback in the same fixed order sequence every time an error occurs, no load-balancing strategy should be provided.
In other words, the dispatcher still supports the failover boolean property even when no load-balancing is enabled.
Without load-balancing, however, the invocation of handlers will always begin with the first according to their order.
For example, this approach works well when there is a clear definition of primary, secondary, tertiary, and so on.
When using the namespace support, the "order" attribute on any endpoint will determine that order.

NOTE: Keep in mind that load-balancing and failover only apply when a channel has more than one subscribed Message Handler.
When using the namespace support, this means that more than one endpoint shares the same channel reference in the "input-channel" attribute.

[[executor-channel]]
===== ExecutorChannel

The `ExecutorChannel` is a point-to-point channel that supports the same dispatcher configuration as `DirectChannel` (load-balancing strategy and the failover boolean property).
The key difference between these two dispatching channel types is that the `ExecutorChannel` delegates to an instance of `TaskExecutor` to perform the dispatch.
This means that the send method typically will not block, but it also means that the handler invocation may not occur in the sender's thread.
It therefore _does not support transactions spanning the sender and receiving handler_.

TIP: Note that there are occasions where the sender may block.
For example, when using a TaskExecutor with a rejection-policy that throttles back on the client (such as the `ThreadPoolExecutor.CallerRunsPolicy`), the sender's thread will execute the method directly anytime the thread pool is at its maximum capacity and the executor's work queue is full.
Since that situation would only occur in a non-predictable way, that obviously cannot be relied upon for transactions.

[[channel-implementations-threadlocalchannel]]
===== Scoped Channel

Spring Integration 1.0 provided a `ThreadLocalChannel` implementation, but that has been removed as of 2.0.
Now, there is a more general way for handling the same requirement by simply adding a "scope" attribute to a channel.
The value of the attribute can be any name of a Scope that is available within the context.
For example, in a web environment, certain Scopes are available, and any custom Scope implementations can be registered with the context.
Here's an example of a ThreadLocal-based scope being applied to a channel, including the registration of the Scope itself.

[source,xml]
----
<int:channel id="threadScopedChannel" scope="thread">
     <int:queue />
</int:channel>

<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
    <property name="scopes">
        <map>
            <entry key="thread" value="org.springframework.context.support.SimpleThreadScope" />
        </map>
    </property>
</bean>
----

The channel above also delegates to a queue internally, but the channel is bound to the current thread, so the contents of the queue are as well.
That way the thread that sends to the channel will later be able to receive those same Messages, but no other thread would be able to access them.
While thread-scoped channels are rarely needed, they can be useful in situations where `DirectChannels` are being used to enforce a single thread of operation but any reply Messages should be sent to a "terminal" channel.
If that terminal channel is thread-scoped, the original sending thread can collect its replies from it.

Now, since any channel can be scoped, you can define your own scopes in addition to Thread Local.

[[channel-interceptors]]
==== Channel Interceptors

One of the advantages of a messaging architecture is the ability to provide common behavior and capture meaningful information about the messages passing through the system in a non-invasive way.
Since the `Message` s are being sent to and received from `MessageChannels`, those channels provide an opportunity for intercepting the send and receive operations.
The `ChannelInterceptor` strategy interface provides methods for each of those operations:
[source,java]
----
public interface ChannelInterceptor {

    Message<?> preSend(Message<?> message, MessageChannel channel);

    void postSend(Message<?> message, MessageChannel channel, boolean sent);

    void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, Exception ex);

    boolean preReceive(MessageChannel channel);

    Message<?> postReceive(Message<?> message, MessageChannel channel);

    void afterReceiveCompletion(Message<?> message, MessageChannel channel, Exception ex);
}
----

After implementing the interface, registering the interceptor with a channel is just a matter of calling:

[source,java]
----
channel.addInterceptor(someChannelInterceptor);
----

The methods that return a Message instance can be used for transforming the Message or can return 'null' to prevent further processing (of course, any of the methods can throw a RuntimeException).
Also, the `preReceive` method can return '`false`' to prevent the receive operation from proceeding.

NOTE: Keep in mind that `receive()` calls are only relevant for `PollableChannels`.
In fact the `SubscribableChannel` interface does not even define a `receive()` method.
The reason for this is that when a Message is sent to a `SubscribableChannel` it will be sent directly to one or more subscribers depending on the type of channel (e.g.
a PublishSubscribeChannel sends to all of its subscribers).
Therefore, the `preReceive(..)` and `postReceive(..)` interceptor methods are only invoked when the interceptor is applied to a `PollableChannel`.

Spring Integration also provides an implementation of the http://eaipatterns.com/WireTap.html[Wire Tap] pattern.
It is a simple interceptor that sends the Message to another channel without otherwise altering the existing flow.
It can be very useful for debugging and monitoring.
An example is shown in <<channel-wiretap>>.

Because it is rarely necessary to implement all of the interceptor methods, a `ChannelInterceptorAdapter` class is also available for sub-classing.
It provides no-op methods (the `void` method is empty, the `Message` returning methods return the Message as-is, and the `boolean` method returns `true`).
Therefore, it is often easiest to extend that class and just implement the method(s) that you need as in the following example.

[source,java]
----
public class CountingChannelInterceptor extends ChannelInterceptorAdapter {

    private final AtomicInteger sendCount = new AtomicInteger();

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        sendCount.incrementAndGet();
        return message;
    }
}
----

TIP: The order of invocation for the interceptor methods depends on the type of channel.
As described above, the queue-based channels are the only ones where the receive method is intercepted in the first place.
Additionally, the relationship between send and receive interception depends on the timing of separate sender and receiver threads.
For example, if a receiver is already blocked while waiting for a message the order could be: preSend, preReceive, postReceive, postSend.
However, if a receiver polls after the sender has placed a message on the channel and already returned, the order would be: preSend, postSend, (some-time-elapses) preReceive, postReceive.
The time that elapses in such a case depends on a number of factors and is therefore generally unpredictable (in fact, the receive may never happen!).
Obviously, the type of queue also plays a role (e.g.
rendezvous vs.
priority).
The bottom line is that you cannot rely on the order beyond the fact that preSend will precede postSend and preReceive will precede postReceive.

Starting with _Spring Framework 4.1_ and Spring Integration 4.1, the `ChannelInterceptor` provides new methods - `afterSendCompletion()` and `afterReceiveCompletion()`.
They are invoked after `send()/receive()` calls, regardless of any exception that is raised, thus allowing for resource cleanup.
Note, the Channel invokes these methods on the ChannelInterceptor List in the reverse order of the initial `preSend()/preReceive()` calls.

[[channel-template]]
==== MessagingTemplate

As you will see when the endpoints and their various configuration options are introduced, Spring Integration provides a foundation for messaging components that enables non-invasive invocation of your application code_from the messaging system_.
However, sometimes it is necessary to invoke the messaging system _from your application code_.
For convenience when implementing such use-cases, Spring Integration provides a `MessagingTemplate` that supports a variety of operations across the Message Channels, including request/reply scenarios.
For example, it is possible to send a request and wait for a reply.

[source,java]
----
MessagingTemplate template = new MessagingTemplate();

Message reply = template.sendAndReceive(someChannel, new GenericMessage("test"));
----

In that example, a temporary anonymous channel would be created internally by the template.
The 'sendTimeout' and 'receiveTimeout' properties may also be set on the template, and other exchange types are also supported.

[source,java]
----
public boolean send(final MessageChannel channel, final Message<?> message) { ...
}

public Message<?> sendAndReceive(final MessageChannel channel, final Message<?> request) { ..
}

public Message<?> receive(final PollableChannel<?> channel) { ...
}
----

NOTE: A less invasive approach that allows you to invoke simple interfaces with payload and/or header values instead of Message instances is described in <<gateway-proxy>>.

[[channel-configuration]]
==== Configuring Message Channels

To create a Message Channel instance, you can use the <channel/> element:
[source,xml]
----
<int:channel id="exampleChannel"/>
----

The default channel type is _Point to Point_.
To create a _Publish Subscribe_ channel, use the <publish-subscribe-channel/> element:
[source,xml]
----
<int:publish-subscribe-channel id="exampleChannel"/>
----

When using the <channel/> element without any sub-elements, it will create a `DirectChannel` instance (a `SubscribableChannel`).

However, you can alternatively provide a variety of <queue/> sub-elements to create any of the pollable channel types (as described in<<channel-implementations>>).
Examples of each are shown below.

[[channel-configuration-directchannel]]
===== DirectChannel Configuration

As mentioned above, `DirectChannel` is the default type.

[source,xml]
----
<int:channel id="directChannel"/>
----

A default channel will have a _round-robin_ load-balancer and will also have failover enabled (See the discussion in <<channel-implementations-directchannel>> for more detail).
To disable one or both of these, add a <dispatcher/> sub-element and configure the attributes:
[source,xml]
----
<int:channel id="failFastChannel">
    <int:dispatcher failover="false"/>
</channel>

<int:channel id="channelWithFixedOrderSequenceFailover">
    <int:dispatcher load-balancer="none"/>
</int:channel>

----

[[channel-datatype-channel]]
===== Datatype Channel Configuration

There are times when a consumer can only process a particular type of payload and you need to therefore ensure the payload type of input Messages.
Of course the first thing that comes to mind is Message Filter.
However all that Message Filter will do is filter out Messages that are not compliant with the requirements of the consumer.
Another way would be to use a Content Based Router and route Messages with non-compliant data-types to specific Transformers to enforce transformation/conversion to the required data-type.
This of course would work, but a simpler way of accomplishing the same thing is to apply the http://www.eaipatterns.com/DatatypeChannel.html[Datatype Channel] pattern.
You can use separate Datatype Channels for each specific payload data-type.

To create a Datatype Channel that only accepts messages containing a certain payload type, provide the fully-qualified class name in the channel element's `datatype` attribute:
[source,xml]
----
<int:channel id="numberChannel" datatype="java.lang.Number"/>
----

Note that the type check passes for any type that is _assignable_ to the channel's datatype.
In other words, the "numberChannel" above would accept messages whose payload is `java.lang.Integer` or `java.lang.Double`.
Multiple types can be provided as a comma-delimited list:
[source,xml]
----
<int:channel id="stringOrNumberChannel" datatype="java.lang.String,java.lang.Number"/>
----

So the 'numberChannel' above will only accept Messages with a data-type of `java.lang.Number`.
But what happens if the payload of the Message is not of the required type? It depends on whether you have defined a bean named "integrationConversionService" that is an instance of Spring's http://static.springsource.org/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-ConversionService-API[Conversion Service].
If not, then an Exception would be thrown immediately, but if you do have an "integrationConversionService" bean defined, it will be used in an attempt to convert the Message's payload to the acceptable type.

You can even register custom converters.
For example, let's say you are sending a Message with a String payload to the 'numberChannel' we configured above.

[source,java]
----
MessageChannel inChannel = context.getBean("numberChannel", MessageChannel.class);
inChannel.send(new GenericMessage<String>("5"));
----

Typically this would be a perfectly legal operation, however since we are using Datatype Channel the result of such operation would generate an exception:
[source,java]
----
Exception in thread "main" org.springframework.integration.MessageDeliveryException:
Channel 'numberChannel'
expected one of the following datataypes [class java.lang.Number],
but received [class java.lang.String]
…
----

And rightfully so since we are requiring the payload type to be a Number while sending a String.
So we need something to convert String to a Number.
All we need to do is implement a Converter.

[source,java]
----
public static class StringToIntegerConverter implements Converter<String, Integer> {
	public Integer convert(String source) {
		return Integer.parseInt(source);
	}
}
----

Then, register it as a Converter with the Integration Conversion Service:
[source,java]
----
<int:converter ref="strToInt"/>

<bean id="strToInt" class="org.springframework.integration.util.Demo.StringToIntegerConverter"/>
----

When the 'converter' element is parsed, it will create the "integrationConversionService" bean on-demand if one is not already defined.
With that Converter in place, the send operation would now be successful since the Datatype Channel will use that Converter to convert the String payload to an Integer.

NOTE: For more information regarding Payload Type Conversion, please read <<payload-type-conversion>>.

Beginning with _version 4.0_, the `integrationConversionService` is invoked by the `DefaultDatatypeChannelMessageConverter`, which looks up the conversion service in the application context.
To use a different conversion technique, you can specify the `message-converter` attribute on the channel.
This must be a reference to a `MessageConverter` implementation.
Only the `fromMessage` method is used, which provides the converter with access to the message headers (for example if the conversion might need information from the headers, such as `content-type`).
The method can return just the converted payload, or a full `Message` object.
If the latter, the converter must be careful to copy all the headers from the inbound message.

Alternatively, declare a `<bean/>` of type `MessageConverter` with an id `"datatypeChannelMessageConverter"` and that converter will be used by all channels with a `datatype`.

[[channel-configuration-queuechannel]]
===== QueueChannel Configuration

To create a `QueueChannel`, use the <queue/> sub-element.
You may specify the channel's capacity:
[source,xml]
----
<int:channel id="queueChannel">
    <queue capacity="25"/>
</int:channel>
----

NOTE: If you do not provide a value for the 'capacity' attribute on this <queue/> sub-element, the resulting queue will be unbounded.
To avoid issues such as OutOfMemoryErrors, it is highly recommended to set an explicit value for a bounded queue.

_Persistent QueueChannel Configuration_

Since a `QueueChannel` provides the capability to buffer Messages, but does so in-memory only by default, it also introduces a possibility that Messages could be lost in the event of a system failure.
To mitigate this risk, a `QueueChannel` may be backed by a persistent implementation of the `MessageGroupStore` strategy interface.
For more details on `MessageGroupStore` and `MessageStore` see <<message-store>>.

When a `QueueChannel` receives a Message, it will add it to the Message Store, and when a Message is polled from a `QueueChannel`, it is removed from the Message Store.

By default, a `QueueChannel` stores its Messages in an in-memory Queue and can therefore lead to the lost message scenario mentioned above.
However Spring Integration provides persistent stores, such as the `JdbcMessageStore`.

You can configure a Message Store for any `QueueChannel` by adding the `message-store` attribute as shown in the next example.

[source,xml]
----
<int:channel id="dbBackedChannel">
    <int:queue message-store="channelStore"/>
</int:channel>

<bean id="channelStore" class="o.s.i.jdbc.store.JdbcChannelMessageStore">
    <property name="dataSource" ref="dataSource"/>
    <property name="channelMessageStoreQueryProvider" ref="queryProvider"/>
</bean>
----

The Spring Integration JDBC module also provides schema DDL for a number of popular databases.
These schemas are located in the _org.springframework.integration.jdbc.store.channel_ package of that module (spring-integration-jdbc).

IMPORTANT: One important feature is that with any transactional persistent store (e.g., JdbcChannelMessageStore), as long as the poller has a transaction configured, a Message removed from the store will only be permanently removed if the transaction completes successfully, otherwise the transaction will roll back and the Message will not be lost.

Many other implementations of the Message Store will be available as the growing number of Spring projects related to "NoSQL" data stores provide the underlying support.
Of course, you can always provide your own implementation of the MessageGroupStore interface if you cannot find one that meets your particular needs.

Since _version 4.0_, it is recommended that `QueueChannel` s are configured to use a `ChannelMessageStore` if possible.
These are generally optimized for this use, when compared with a general message store.
If the `ChannelMessageStore` is a `ChannelPriorityMessageStore` the messages will be received in FIFO within priority order.
The notion of priority is determined by the message store implementation.
For example the Java Configuration for the <<mongodb-priority-channel-message-store>>:

[source,java]
----
@Bean
public BasicMessageGroupStore mongoDbChannelMessageStore(MongoDbFactory mongoDbFactory) {
    MongoDbChannelMessageStore store = new MongoDbChannelMessageStore(mongoDbFactory);
    store.setPriorityEnabled(true);
    return store;
}

@Bean
public PollableChannel priorityQueue(BasicMessageGroupStore mongoDbChannelMessageStore) {
   return new QueueChannel(new MessageGroupQueue(mongoDbChannelMessageStore, "priorityQueue"));
}
----

NOTE: Pay attention to the `MessageGroupQueue` class.
That is a `BlockingQueue` implementation to utilize the `MessageGroupStore` operations.

The same with Java DSL may look like:

[source,java]
----
@Bean
public IntegrationFlow priorityFlow(PriorityCapableChannelMessageStore mongoDbChannelMessageStore) {
    return IntegrationFlows.from((Channels c) ->
            c.priority("priorityChannel", mongoDbChannelMessageStore, "priorityGroup"))
            ....
            .get();
}
----

Another option to customize the QueueChannel environment is provided by the `ref` attribute of the `<int:queue>` sub-element.
This attribute implies the reference to any `java.util.Queue` implementation.
An implementation is provided by the https://github.com/reactor/reactor[Project Reactor] and its `reactor.queue.PersistentQueue` implementation for the https://github.com/OpenHFT/Chronicle-Queue[IndexedChronicle]:

[source,java]
----
@Bean
public QueueChannel reactorQueue() {
    return new QueueChannel(new PersistentQueueSpec<Message<?>>()
                    .codec(new JavaSerializationCodec<Message<?>>())
                    .basePath(System.getProperty("java.io.tmpdir") + "/reactor-queue")
                    .get());
}
----

[[channel-configuration-pubsubchannel]]
===== PublishSubscribeChannel Configuration

To create a `PublishSubscribeChannel`, use the <publish-subscribe-channel/> element.
When using this element, you can also specify the `task-executor` used for publishing Messages (if none is specified it simply publishes in the sender's thread):
[source,xml]
----
<int:publish-subscribe-channel id="pubsubChannel" task-executor="someExecutor"/>
----

If you are providing a _Resequencer_ or _Aggregator_ downstream from a `PublishSubscribeChannel`, then you can set the 'apply-sequence' property on the channel to `true`.
That will indicate that the channel should set the sequence-size and sequence-number Message headers as well as the correlation id prior to passing the Messages along.
For example, if there are 5 subscribers, the sequence-size would be set to 5, and the Messages would have sequence-number header values ranging from 1 to 5.
[source,xml]
----
<int:publish-subscribe-channel id="pubsubChannel" apply-sequence="true"/>
----

NOTE: The `apply-sequence` value is `false` by default so that a Publish Subscribe Channel can send the exact same Message instances to multiple outbound channels.
Since Spring Integration enforces immutability of the payload and header references, the channel creates new Message instances with the same payload reference but different header values when the flag is set to `true`.

[[channel-configuration-executorchannel]]
===== ExecutorChannel

To create an `ExecutorChannel`, add the <dispatcher> sub-element along with a `task-executor` attribute.
Its value can reference any `TaskExecutor` within the context.
For example, this enables configuration of a thread-pool for dispatching messages to subscribed handlers.
As mentioned above, this does break the "single-threaded" execution context between sender and receiver so that any active transaction context will not be shared by the invocation of the handler (i.e.
the handler may throw an Exception, but the send invocation has already returned successfully).

[source,xml]
----
<int:channel id="executorChannel">
    <int:dispatcher task-executor="someExecutor"/>
</int:channel>
----

[NOTE]
=====
The `load-balancer` and `failover` options are also both available on the <dispatcher/> sub-element as described above in <<channel-configuration-directchannel>>.
The same defaults apply as well.
So, the channel will have a round-robin load-balancing strategy with failover enabled unless explicit configuration is provided for one or both of those attributes.

[source,xml]
----
<int:channel id="executorChannelWithoutFailover">
    <int:dispatcher task-executor="someExecutor" failover="false"/>
</int:channel>
----
=====

[[channel-configuration-prioritychannel]]
===== PriorityChannel Configuration

To create a `PriorityChannel`, use the <priority-queue/> sub-element:
[source,xml]
----
<int:channel id="priorityChannel">
    <int:priority-queue capacity="20"/>
</int:channel>
----

By default, the channel will consult the `priority` header of the message.
However, a custom `Comparator` reference may be provided instead.
Also, note that the `PriorityChannel` (like the other types) does support the `datatype` attribute.
As with the QueueChannel, it also supports a `capacity` attribute.
The following example demonstrates all of these:
[source,xml]
----
<int:channel id="priorityChannel" datatype="example.Widget">
    <int:priority-queue comparator="widgetComparator"
                    capacity="10"/>
</int:channel>

----

Since _version 4.0_, the `priority-channel` child element supports the `message-store` option (`comparator` is not allowed in that case).
The message store must be a `PriorityCapableChannelMessageStore` and, in this case, the namespace parser will declare a `QueueChannel` instead of a `PriorityChannel`.
Implementations of the `PriorityCapableChannelMessageStore` are currently provided for `Redis`, `JDBC` and `MongoDB`.
See <<channel-configuration-queuechannel>>.

[[channel-configuration-rendezvouschannel]]
===== RendezvousChannel Configuration

A `RendezvousChannel` is created when the queue sub-element is a <rendezvous-queue>.
It does not provide any additional configuration options to those described above, and its queue does not accept any capacity value since it is a 0-capacity direct handoff queue.

[source,xml]
----
<int:channel id="rendezvousChannel"/>
    <int:rendezvous-queue/>
</int:channel>

----

[[channel-configuration-threadlocalchannel]]
===== Scoped Channel Configuration

Any channel can be configured with a "scope" attribute.

[source,xml]
----
<int:channel id="threadLocalChannel" scope="thread"/>
----

[[channel-configuration-interceptors]]
===== Channel Interceptor Configuration

Message channels may also have interceptors as described in <<channel-interceptors>>.
The `<interceptors/>` sub-element can be added within a `<channel/>` (or the more specific element types).
Provide the `ref` attribute to reference any Spring-managed object that implements the `ChannelInterceptor` interface:
[source,xml]
----
<int:channel id="exampleChannel">
    <int:interceptors>
        <ref bean="trafficMonitoringInterceptor"/>
    </int:interceptors>
</int:channel>
----

In general, it is a good idea to define the interceptor implementations in a separate location since they usually provide common behavior that can be reused across multiple channels.

[[global-channel-configuration-interceptors]]
===== Global Channel Interceptor Configuration

Channel Interceptors provide a clean and concise way of applying cross-cutting behavior per individual channel.
If the same behavior should be applied on multiple channels, configuring the same set of interceptors for each channel _would not be_ the most efficient way.
To avoid repeated configuration while also enabling interceptors to apply to multiple channels, Spring Integration provides _Global Interceptors_.
Look at the example below:
[source,xml]
----
<int:channel-interceptor pattern="input*, bar*, foo" order="3">
    <bean class="foo.barSampleInterceptor"/>
</int:channel-interceptor>
----

or

[source,xml]
----
<int:channel-interceptor ref="myInterceptor" pattern="input*, bar*, foo" order="3"/>

<bean id="myInterceptor" class="foo.barSampleInterceptor"/>
----

Each <channel-interceptor/> element allows you to define a global interceptor which will be applied on all channels that match any patterns defined via the `pattern` attribute.
In the above case the global interceptor will be applied on the 'foo' channel and all other channels that begin with 'bar' or 'input'.
The _order_ attribute allows you to manage where this interceptor will be injected if there are multiple interceptors on a given channel.
For example, channel 'inputChannel' could have individual interceptors configured locally (see below):
[source,xml]
----
<int:channel id="inputChannel"> 
  <int:interceptors>
    <int:wire-tap channel="logger"/> 
  </int:interceptors>
</int:channel>
----

A reasonable question is how will a global interceptor be injected in relation to other interceptors configured locally or through other global interceptor definitions? The current implementation provides a very simple mechanism for defining the order of interceptor execution.
A positive number in the `order` attribute will ensure interceptor injection after any existing interceptors and a negative number will ensure that the interceptor is injected before existing interceptors.
This means that in the above example, the global interceptor will be injected _AFTER_ (since its order is greater than 0) the 'wire-tap' interceptor configured locally.
If there were another global interceptor with a matching `pattern`, its order would be determined by comparing the values of the `order` attribute.
To inject a global interceptor _BEFORE_ the existing interceptors, use a negative value for the `order` attribute.

NOTE: Note that both the `order` and `pattern` attributes are optional.
The default value for `order` will be 0 and for `pattern`, the default is '*' (to match all channels).

[[channel-wiretap]]
===== Wire Tap

As mentioned above, Spring Integration provides a simple _Wire Tap_ interceptor out of the box.
You can configure a _Wire Tap_ on any channel within an <interceptors/> element.
This is especially useful for debugging, and can be used in conjunction with Spring Integration's logging Channel Adapter as follows:
[source,xml]
----
<int:channel id="in">
    <int:interceptors>
        <int:wire-tap channel="logger"/>
    </int:interceptors>
</int:channel>

<int:logging-channel-adapter id="logger" level="DEBUG"/>
----

TIP: The 'logging-channel-adapter' also accepts an 'expression' attribute so that you can evaluate a SpEL expression against 'payload' and/or 'headers' variables.
Alternatively, to simply log the full Message toString() result, provide a value of "true" for the 'log-full-message' attribute.
That is `false` by default so that only the payload is logged.
Setting that to `true` enables logging of all headers in addition to the payload.
The 'expression' option does provide the most flexibility, however (e.g.
expression="payload.user.name").

*A little more on Wire Tap*

One of the common misconceptions about the wire tap and other similar components (<<message-publishing-config>>) is that they are automatically asynchronous in nature.
Wire-tap as a component is not invoked asynchronously be default.
Instead, Spring Integration focuses on a single unified approach to configuring asynchronous behavior: the Message Channel.
What makes certain parts of the message flow _sync_ or _async_ is the type of _Message Channel_ that has been configured within that flow.
That is one of the primary benefits of the Message Channel abstraction.
From the inception of the framework, we have always emphasized the need and the value of the _Message Channel_ as a first-class citizen of the framework.
It is not just an internal, implicit realization of the EIP pattern, it is fully exposed as a configurable component to the end user.
So, the Wire-tap component is ONLY responsible for performing the following 3 tasks:

* intercept a message flow by tapping into a channel (e.g., channelA)

* grab each message

* send the message to another channel (e.g., channelB)



It is essentially a variation of the Bridge, but it is encapsulated within a channel definition (and hence easier to enable and disable without disrupting a flow).
Also, unlike the bridge, it basically forks another message flow.
Is that flow _synchronous_ or _asynchronous_? The answer simply depends on the type of _Message Channel_ that 'channelB' is.
And, now you know that we have: _Direct Channel_, _Pollable Channel_, and _Executor Channel_ as options.
The last two do break the thread boundary making communication via such channels_asynchronous_ simply because the dispatching of the message from that channel to its subscribed handlers happens on a different thread than the one used to send the message to that channel.
That is what is going to make your wire-tap flow _sync_ or _async_.
It is consistent with other components within the framework (e.g., Message Publisher) and actually brings a level of consistency and simplicity by sparing you from worrying in advance (other than writing thread safe code) whether a particular piece of code should be implemented as _sync_ or _async_.
The actual wiring of two pieces of code (component A and component B) via _Message Channel_ is what makes their collaboration _sync_ or _async_.
You may even want to change from _sync_ to _async_ in the future and _Message Channel_ is what's going to allow you to do it swiftly without ever touching the code.

One final point regarding the Wire Tap is that, despite the rationale provided above for not being async by default, one should keep in mind it is usually desirable to hand off the Message as soon as possible.
Therefore, it would be quite common to use an asynchronous channel option as the wire-tap's outbound channel.
Nonetheless, another reason that we do not enforce asynchronous behavior by default is that you might not want to break a transactional boundary.
Perhaps you are using the Wire Tap for auditing purposes, and you DO want the audit Messages to be sent within the original transaction.
As an example, you might connect the wire-tap to a JMS outbound-channel-adapter.
That way, you get the best of both worlds: 1) the sending of a JMS Message can occur within the transaction while 2) it is still a "fire-and-forget" action thereby preventing any noticeable delay in the main message flow.

IMPORTANT: Starting with _version 4.0_, it is important to avoid circular references when an interceptor (such as `WireTap`) references a channel itself.
You need to exclude such channels from those being intercepted by the current interceptor.
This can be done with appropriate `patterns` or programmatically.
If you have a custom `ChannelInterceptor` that references a `channel`, consider implementing `VetoCapableInterceptor`.
That way, the framework will ask the interceptor if it's OK to intercept each channel that is a candidate based on the pattern.
You can also add runtime protection in the interceptor methods that ensures that the channel is not one that is referenced by the interceptor.
The `WireTap` uses both of these techniques.

[[conditional-wiretap]]
===== Conditional Wire Taps

Wire taps can be made conditional, using the `selector` or `selector-expression` attributes.
The `selector` references a `MessageSelector` bean, which can determine at runtime whether the message should go to the tap channel.
Similarly, the` selector-expression` is a boolean SpEL expression that performs the same purpose - if the expression evaluates to true, the message will be sent to the tap channel.

[[channel-global-wiretap]]
===== Global Wire Tap Configuration

It is possible to configure a global wire tap as a special case of the <<global-channel-configuration-interceptors>>.
Simply configure a top level `wire-tap` element.
Now, in addition to the normal `wire-tap` namespace support, the `pattern` and `order` attributes are supported and work in exactly the same way as with the `channel-interceptor`
[source,xml]
----
<int:wire-tap pattern="input*, bar*, foo" order="3" channel="wiretapChannel"/>
----

TIP: A global wire tap provides a convenient way to configure a single channel wire tap externally without modifying the existing channel configuration.
Simply set the `pattern` attribute to the target channel name.
For example, This technique may be used to configure a test case to verify messages on a channel.

[[channel-special-channels]]
==== Special Channels

If namespace support is enabled, there are two special channels defined within the application context by default: `errorChannel` and `nullChannel`.
The 'nullChannel' acts like `/dev/null`, simply logging any Message sent to it at DEBUG level and returning immediately.
Any time you face channel resolution errors for a reply that you don't care about, you can set the affected component's `output-channel` attribute to 'nullChannel' (the name 'nullChannel' is reserved within the application context).
The 'errorChannel' is used internally for sending error messages and may be overridden with a custom configuration.
This is discussed in greater detail in <<namespace-errorhandler>>.
